/* tslint:disable */
/* eslint-disable */
/**
 * Airbrowser API
 * Undetectable Chrome-in-Docker for developers and agents (REST + MCP)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface BaseResponse {
    /**
     * Operation success
     */
    'success': boolean;
    /**
     * Status message
     */
    'message': string;
    /**
     * Unix timestamp
     */
    'timestamp': number;
}
export interface BrowsersRequest {
    /**
     * action
     */
    'action': BrowsersRequestActionEnum;
    /**
     * browser_id
     */
    'browser_id'?: string;
}

export const BrowsersRequestActionEnum = {
    List: 'list',
    Info: 'info',
    CloseAll: 'close_all',
    Kill: 'kill',
    KillAll: 'kill_all',
    Restore: 'restore'
} as const;

export type BrowsersRequestActionEnum = typeof BrowsersRequestActionEnum[keyof typeof BrowsersRequestActionEnum];

export interface ClickRequest {
    /**
     * selector
     */
    'selector': string;
    /**
     * timeout
     */
    'timeout'?: number;
    /**
     * by
     */
    'by'?: string;
    /**
     * if_visible
     */
    'if_visible'?: boolean;
}
export interface ConsoleLogsRequest {
    /**
     * action
     */
    'action': ConsoleLogsRequestActionEnum;
    /**
     * limit
     */
    'limit'?: number;
}

export const ConsoleLogsRequestActionEnum = {
    Get: 'get',
    Clear: 'clear',
    Enable: 'enable',
    Disable: 'disable'
} as const;

export type ConsoleLogsRequestActionEnum = typeof ConsoleLogsRequestActionEnum[keyof typeof ConsoleLogsRequestActionEnum];

export interface CreateBrowserRequest {
    /**
     * uc
     */
    'uc'?: boolean;
    /**
     * proxy
     */
    'proxy'?: string;
    /**
     * window_size
     */
    'window_size'?: Array<number>;
    /**
     * user_agent
     */
    'user_agent'?: string;
    /**
     * disable_gpu
     */
    'disable_gpu'?: boolean;
    /**
     * disable_images
     */
    'disable_images'?: boolean;
    /**
     * disable_javascript
     */
    'disable_javascript'?: boolean;
    /**
     * extensions
     */
    'extensions'?: Array<string>;
    /**
     * custom_args
     */
    'custom_args'?: Array<string>;
    /**
     * profile_name
     */
    'profile_name'?: string;
}
export interface CreateProfileRequest {
    /**
     * Profile name
     */
    'name': string;
}
export interface DetectCoordinatesRequest {
    /**
     * prompt
     */
    'prompt': string;
    /**
     * fx
     */
    'fx'?: number;
    /**
     * fy
     */
    'fy'?: number;
}
export interface DialogRequest {
    /**
     * action
     */
    'action': DialogRequestActionEnum;
    /**
     * text
     */
    'text'?: string;
}

export const DialogRequestActionEnum = {
    Get: 'get',
    Accept: 'accept',
    Dismiss: 'dismiss'
} as const;

export type DialogRequestActionEnum = typeof DialogRequestActionEnum[keyof typeof DialogRequestActionEnum];

export interface EmulateRequest {
    /**
     * action
     */
    'action'?: EmulateRequestActionEnum;
    /**
     * device
     */
    'device'?: string;
    /**
     * width
     */
    'width'?: number;
    /**
     * height
     */
    'height'?: number;
    /**
     * device_scale_factor
     */
    'device_scale_factor'?: number;
    /**
     * mobile
     */
    'mobile'?: boolean;
    /**
     * user_agent
     */
    'user_agent'?: string;
}

export const EmulateRequestActionEnum = {
    Set: 'set',
    Clear: 'clear',
    ListDevices: 'list_devices'
} as const;

export type EmulateRequestActionEnum = typeof EmulateRequestActionEnum[keyof typeof EmulateRequestActionEnum];

export interface ErrorResponse {
    /**
     * Operation success (false)
     */
    'success'?: boolean;
    /**
     * Error message
     */
    'message'?: string;
    /**
     * Unix timestamp
     */
    'timestamp'?: number;
}
export interface ExecuteScriptRequest {
    /**
     * script
     */
    'script': string;
}
export interface FillFormRequest {
    /**
     * fields
     */
    'fields': Array<object>;
    /**
     * by
     */
    'by'?: string;
}
export interface GenericResponse {
    /**
     * Whether the operation succeeded
     */
    'success'?: boolean;
    /**
     * Response message
     */
    'message'?: string;
    /**
     * Response data
     */
    'data'?: object;
}
export interface GuiClickRequest {
    /**
     * selector
     */
    'selector'?: string;
    /**
     * x
     */
    'x'?: number;
    /**
     * y
     */
    'y'?: number;
    /**
     * timeframe
     */
    'timeframe'?: number;
    /**
     * fx
     */
    'fx'?: number;
    /**
     * fy
     */
    'fy'?: number;
}
export interface GuiHoverXyRequest {
    /**
     * x
     */
    'x': number;
    /**
     * y
     */
    'y': number;
    /**
     * timeframe
     */
    'timeframe'?: number;
}
export interface GuiPressKeysXyRequest {
    /**
     * x
     */
    'x': number;
    /**
     * y
     */
    'y': number;
    /**
     * keys
     */
    'keys': string;
    /**
     * timeframe
     */
    'timeframe'?: number;
}
export interface GuiTypeXyRequest {
    /**
     * x
     */
    'x': number;
    /**
     * y
     */
    'y': number;
    /**
     * text
     */
    'text': string;
    /**
     * timeframe
     */
    'timeframe'?: number;
}
export interface HealthStatus {
    /**
     * Health status
     */
    'status'?: string;
    /**
     * Server version
     */
    'version'?: string;
    /**
     * Whether AI vision tools are available
     */
    'vision_enabled'?: boolean;
    /**
     * Pool status information
     */
    'pool'?: object;
    /**
     * Unix timestamp
     */
    'timestamp'?: number;
}
export interface HistoryRequest {
    /**
     * action
     */
    'action': HistoryRequestActionEnum;
}

export const HistoryRequestActionEnum = {
    Back: 'back',
    Forward: 'forward',
    Refresh: 'refresh'
} as const;

export type HistoryRequestActionEnum = typeof HistoryRequestActionEnum[keyof typeof HistoryRequestActionEnum];

export interface MouseRequest {
    /**
     * action
     */
    'action': MouseRequestActionEnum;
    /**
     * selector
     */
    'selector'?: string;
    /**
     * source
     */
    'source'?: string;
    /**
     * target
     */
    'target'?: string;
    /**
     * by
     */
    'by'?: string;
}

export const MouseRequestActionEnum = {
    Hover: 'hover',
    Drag: 'drag'
} as const;

export type MouseRequestActionEnum = typeof MouseRequestActionEnum[keyof typeof MouseRequestActionEnum];

export interface NavigateBrowserRequest {
    /**
     * url
     */
    'url': string;
    /**
     * timeout
     */
    'timeout'?: number;
}
export interface NetworkLogsRequest {
    /**
     * action
     */
    'action': NetworkLogsRequestActionEnum;
    /**
     * limit
     */
    'limit'?: number;
}

export const NetworkLogsRequestActionEnum = {
    Get: 'get',
    Clear: 'clear',
    Enable: 'enable',
    Disable: 'disable'
} as const;

export type NetworkLogsRequestActionEnum = typeof NetworkLogsRequestActionEnum[keyof typeof NetworkLogsRequestActionEnum];

export interface PerformanceRequest {
    /**
     * action
     */
    'action': PerformanceRequestActionEnum;
    /**
     * categories
     */
    'categories'?: string;
}

export const PerformanceRequestActionEnum = {
    StartTrace: 'start_trace',
    StopTrace: 'stop_trace',
    Metrics: 'metrics',
    Analyze: 'analyze'
} as const;

export type PerformanceRequestActionEnum = typeof PerformanceRequestActionEnum[keyof typeof PerformanceRequestActionEnum];

export interface PoolScaled {
    /**
     * Operation success
     */
    'success': boolean;
    /**
     * Status message
     */
    'message': string;
    /**
     * Unix timestamp
     */
    'timestamp': number;
    /**
     * Scale result
     */
    'data'?: ScaleData;
}
export interface PressKeysRequest {
    /**
     * selector
     */
    'selector': string;
    /**
     * keys
     */
    'keys': string;
    /**
     * by
     */
    'by'?: string;
}
export interface ProfileInfo {
    /**
     * Profile name
     */
    'name'?: string;
    /**
     * Profile storage path
     */
    'path'?: string;
    /**
     * Profile size in MB
     */
    'size_mb'?: number;
    /**
     * Last used timestamp (ISO format)
     */
    'last_used'?: string;
    /**
     * Whether profile is currently in use by a browser
     */
    'in_use'?: boolean;
}
export interface ProfileListData {
    /**
     * List of profiles
     */
    'profiles'?: Array<ProfileInfo>;
}
export interface ProfileListResponse {
    /**
     * Operation success
     */
    'success'?: boolean;
    /**
     * Status message
     */
    'message'?: string;
    /**
     * Unix timestamp
     */
    'timestamp'?: number;
    'data'?: ProfileListData;
}
export interface ProfileResponse {
    /**
     * Operation success
     */
    'success'?: boolean;
    /**
     * Status message
     */
    'message'?: string;
    /**
     * Unix timestamp
     */
    'timestamp'?: number;
    'data'?: ProfileInfo;
}
export interface ResizeRequest {
    /**
     * width
     */
    'width': number;
    /**
     * height
     */
    'height': number;
}
export interface ScaleData {
    /**
     * New maximum browser count
     */
    'new_max_browsers'?: number;
}
export interface ScalePool {
    /**
     * New maximum number of browsers
     */
    'target_size': number;
}
export interface ScrollRequest {
    /**
     * selector
     */
    'selector'?: string;
    /**
     * x
     */
    'x'?: number;
    /**
     * y
     */
    'y'?: number;
    /**
     * delta_x
     */
    'delta_x'?: number;
    /**
     * delta_y
     */
    'delta_y'?: number;
    /**
     * behavior
     */
    'behavior'?: string;
    /**
     * by
     */
    'by'?: string;
}
export interface SelectRequest {
    /**
     * selector
     */
    'selector': string;
    /**
     * action
     */
    'action'?: SelectRequestActionEnum;
    /**
     * value
     */
    'value'?: string;
    /**
     * text
     */
    'text'?: string;
    /**
     * index
     */
    'index'?: number;
    /**
     * by
     */
    'by'?: string;
}

export const SelectRequestActionEnum = {
    Select: 'select',
    Options: 'options'
} as const;

export type SelectRequestActionEnum = typeof SelectRequestActionEnum[keyof typeof SelectRequestActionEnum];

export interface SnapshotRequest {
    /**
     * snapshot_type
     */
    'snapshot_type'?: string;
}
export interface TabsRequest {
    /**
     * action
     */
    'action': TabsRequestActionEnum;
    /**
     * url
     */
    'url'?: string;
    /**
     * index
     */
    'index'?: number;
    /**
     * handle
     */
    'handle'?: string;
}

export const TabsRequestActionEnum = {
    List: 'list',
    New: 'new',
    Switch: 'switch',
    Close: 'close',
    Current: 'current'
} as const;

export type TabsRequestActionEnum = typeof TabsRequestActionEnum[keyof typeof TabsRequestActionEnum];

export interface TakeScreenshotRequest {
    /**
     * full_page
     */
    'full_page'?: boolean;
}
export interface TypeTextRequest {
    /**
     * selector
     */
    'selector': string;
    /**
     * text
     */
    'text': string;
    /**
     * timeout
     */
    'timeout'?: number;
    /**
     * by
     */
    'by'?: string;
}
export interface UploadFileRequest {
    /**
     * selector
     */
    'selector': string;
    /**
     * file_path
     */
    'file_path': string;
    /**
     * by
     */
    'by'?: string;
}
export interface WaitElementRequest {
    /**
     * selector
     */
    'selector': string;
    /**
     * until
     */
    'until': WaitElementRequestUntilEnum;
    /**
     * timeout
     */
    'timeout'?: number;
    /**
     * by
     */
    'by'?: string;
}

export const WaitElementRequestUntilEnum = {
    Visible: 'visible',
    Hidden: 'hidden'
} as const;

export type WaitElementRequestUntilEnum = typeof WaitElementRequestUntilEnum[keyof typeof WaitElementRequestUntilEnum];


/**
 * BrowserApi - axios parameter creator
 */
export const BrowserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Admin: list all, get info, or close all browsers
         * @param {BrowsersRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        browsers: async (payload: BrowsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('browsers', 'payload', payload)
            const localVarPath = `/browser/browsers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if element exists or is visible
         * @param {string} browserId 
         * @param {string} selector selector
         * @param {string} check check
         * @param {string} [by] by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkElement: async (browserId: string, selector: string, check: string, by?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('checkElement', 'browserId', browserId)
            // verify required parameter 'selector' is not null or undefined
            assertParamExists('checkElement', 'selector', selector)
            // verify required parameter 'check' is not null or undefined
            assertParamExists('checkElement', 'check', check)
            const localVarPath = `/browser/{browser_id}/check_element`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (selector !== undefined) {
                localVarQueryParameter['selector'] = selector;
            }

            if (check !== undefined) {
                localVarQueryParameter['check'] = check;
            }

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use if_visible=True to only click if visible.
         * @summary Click element
         * @param {string} browserId 
         * @param {ClickRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        click: async (browserId: string, payload: ClickRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('click', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('click', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/click`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Close browser instance
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeBrowser: async (browserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('closeBrowser', 'browserId', browserId)
            const localVarPath = `/browser/{browser_id}/close_browser`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Console logs: get or clear
         * @param {string} browserId 
         * @param {ConsoleLogsRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consoleLogs: async (browserId: string, payload: ConsoleLogsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('consoleLogs', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('consoleLogs', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/console_logs`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create browser instance with optional persistent profile
         * @param {CreateBrowserRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowser: async (payload: CreateBrowserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createBrowser', 'payload', payload)
            const localVarPath = `/browser/create_browser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Args:     browser_id: Browser instance identifier     prompt: Natural language description of element to find     fx: Fractional x offset for click point (0.0=left, 0.5=center, 1.0=right).         If None, auto-bias is applied for wide elements (0.25 for aspect ratio > 10).     fy: Fractional y offset for click point (0.0=top, 0.5=center, 1.0=bottom).
         * @summary Detect element coordinates using vision
         * @param {string} browserId 
         * @param {DetectCoordinatesRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectCoordinates: async (browserId: string, payload: DetectCoordinatesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('detectCoordinates', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('detectCoordinates', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/detect_coordinates`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dialogs: get, accept, dismiss
         * @param {string} browserId 
         * @param {DialogRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dialog: async (browserId: string, payload: DialogRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('dialog', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('dialog', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/dialog`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Emulation: set, clear, list_devices
         * @param {string} browserId 
         * @param {EmulateRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emulate: async (browserId: string, payload: EmulateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('emulate', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('emulate', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/emulate`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute JavaScript
         * @param {string} browserId 
         * @param {ExecuteScriptRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeScript: async (browserId: string, payload: ExecuteScriptRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('executeScript', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('executeScript', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/execute_script`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fill multiple form fields
         * @param {string} browserId 
         * @param {FillFormRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fillForm: async (browserId: string, payload: FillFormRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('fillForm', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('fillForm', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/fill_form`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the WebSocket URL that external tools (Playwright, Puppeteer, etc.) can use to connect directly to Chrome\'s DevTools Protocol for advanced automation like network interception, performance profiling, or custom CDP commands.  The returned URL format: ws://host:port/devtools/browser/{guid}  Note: The URL uses the container\'s internal address. For external access, ensure the CDP port is exposed and use the appropriate host address.
         * @summary Get Chrome DevTools Protocol WebSocket URL for direct CDP access
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCdpEndpoint: async (browserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('getCdpEndpoint', 'browserId', browserId)
            const localVarPath = `/browser/{browser_id}/get_cdp_endpoint`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get page HTML
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContent: async (browserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('getContent', 'browserId', browserId)
            const localVarPath = `/browser/{browser_id}/get_content`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get element text, attribute, or property
         * @param {string} browserId 
         * @param {string} selector selector
         * @param {string} dataType data_type
         * @param {string} [name] name
         * @param {string} [by] by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getElementData: async (browserId: string, selector: string, dataType: string, name?: string, by?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('getElementData', 'browserId', browserId)
            // verify required parameter 'selector' is not null or undefined
            assertParamExists('getElementData', 'selector', selector)
            // verify required parameter 'dataType' is not null or undefined
            assertParamExists('getElementData', 'dataType', dataType)
            const localVarPath = `/browser/{browser_id}/get_element_data`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (selector !== undefined) {
                localVarQueryParameter['selector'] = selector;
            }

            if (dataType !== undefined) {
                localVarQueryParameter['data_type'] = dataType;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current URL
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrl: async (browserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('getUrl', 'browserId', browserId)
            const localVarPath = `/browser/{browser_id}/get_url`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GUI click by selector or coordinates
         * @param {string} browserId 
         * @param {GuiClickRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guiClick: async (browserId: string, payload: GuiClickRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('guiClick', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('guiClick', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/gui_click`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GUI hover at coordinates
         * @param {string} browserId 
         * @param {GuiHoverXyRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guiHoverXy: async (browserId: string, payload: GuiHoverXyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('guiHoverXy', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('guiHoverXy', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/gui_hover_xy`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Press keys at coordinates (click to focus, then send keys)
         * @param {string} browserId 
         * @param {GuiPressKeysXyRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guiPressKeysXy: async (browserId: string, payload: GuiPressKeysXyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('guiPressKeysXy', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('guiPressKeysXy', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/gui_press_keys_xy`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GUI type at coordinates - clicks then types text
         * @param {string} browserId 
         * @param {GuiTypeXyRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guiTypeXy: async (browserId: string, payload: GuiTypeXyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('guiTypeXy', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('guiTypeXy', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/gui_type_xy`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary History: back, forward, or refresh
         * @param {string} browserId 
         * @param {HistoryRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        history: async (browserId: string, payload: HistoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('history', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('history', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/history`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mouse: hover or drag
         * @param {string} browserId 
         * @param {MouseRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mouse: async (browserId: string, payload: MouseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('mouse', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('mouse', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/mouse`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Navigate to URL
         * @param {string} browserId 
         * @param {NavigateBrowserRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        navigateBrowser: async (browserId: string, payload: NavigateBrowserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('navigateBrowser', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('navigateBrowser', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/navigate`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Network logs: get or clear
         * @param {string} browserId 
         * @param {NetworkLogsRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkLogs: async (browserId: string, payload: NetworkLogsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('networkLogs', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('networkLogs', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/network_logs`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Performance: start_trace, stop_trace, metrics, analyze
         * @param {string} browserId 
         * @param {PerformanceRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performance: async (browserId: string, payload: PerformanceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('performance', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('performance', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/performance`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Press keyboard keys
         * @param {string} browserId 
         * @param {PressKeysRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pressKeys: async (browserId: string, payload: PressKeysRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('pressKeys', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('pressKeys', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/press_keys`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resize viewport
         * @param {string} browserId 
         * @param {ResizeRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resize: async (browserId: string, payload: ResizeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('resize', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('resize', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/resize`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Scroll to element/coords or by delta
         * @param {string} browserId 
         * @param {ScrollRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scroll: async (browserId: string, payload: ScrollRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('scroll', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('scroll', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/scroll`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Select dropdown: select option or get options
         * @param {string} browserId 
         * @param {SelectRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        select: async (browserId: string, payload: SelectRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('select', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('select', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/select`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DOM or accessibility snapshot
         * @param {string} browserId 
         * @param {SnapshotRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshot: async (browserId: string, payload: SnapshotRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('snapshot', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('snapshot', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/snapshot`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tabs: list, new, switch, close, current
         * @param {string} browserId 
         * @param {TabsRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tabs: async (browserId: string, payload: TabsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('tabs', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('tabs', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/tabs`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Take screenshot
         * @param {string} browserId 
         * @param {TakeScreenshotRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        takeScreenshot: async (browserId: string, payload: TakeScreenshotRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('takeScreenshot', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('takeScreenshot', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/screenshot`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Type text into element
         * @param {string} browserId 
         * @param {TypeTextRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeText: async (browserId: string, payload: TypeTextRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('typeText', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('typeText', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/type`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload file to input
         * @param {string} browserId 
         * @param {UploadFileRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (browserId: string, payload: UploadFileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('uploadFile', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('uploadFile', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/upload_file`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Wait for element to be visible or hidden
         * @param {string} browserId 
         * @param {WaitElementRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitElement: async (browserId: string, payload: WaitElementRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('waitElement', 'browserId', browserId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('waitElement', 'payload', payload)
            const localVarPath = `/browser/{browser_id}/wait_element`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary AI page analysis - what\'s visible
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whatIsVisible: async (browserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'browserId' is not null or undefined
            assertParamExists('whatIsVisible', 'browserId', browserId)
            const localVarPath = `/browser/{browser_id}/what_is_visible`
                .replace(`{${"browser_id"}}`, encodeURIComponent(String(browserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrowserApi - functional programming interface
 */
export const BrowserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrowserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Admin: list all, get info, or close all browsers
         * @param {BrowsersRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async browsers(payload: BrowsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.browsers(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.browsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if element exists or is visible
         * @param {string} browserId 
         * @param {string} selector selector
         * @param {string} check check
         * @param {string} [by] by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkElement(browserId: string, selector: string, check: string, by?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkElement(browserId, selector, check, by, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.checkElement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use if_visible=True to only click if visible.
         * @summary Click element
         * @param {string} browserId 
         * @param {ClickRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async click(browserId: string, payload: ClickRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.click(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.click']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Close browser instance
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeBrowser(browserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeBrowser(browserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.closeBrowser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Console logs: get or clear
         * @param {string} browserId 
         * @param {ConsoleLogsRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consoleLogs(browserId: string, payload: ConsoleLogsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consoleLogs(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.consoleLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create browser instance with optional persistent profile
         * @param {CreateBrowserRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBrowser(payload: CreateBrowserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBrowser(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.createBrowser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Args:     browser_id: Browser instance identifier     prompt: Natural language description of element to find     fx: Fractional x offset for click point (0.0=left, 0.5=center, 1.0=right).         If None, auto-bias is applied for wide elements (0.25 for aspect ratio > 10).     fy: Fractional y offset for click point (0.0=top, 0.5=center, 1.0=bottom).
         * @summary Detect element coordinates using vision
         * @param {string} browserId 
         * @param {DetectCoordinatesRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detectCoordinates(browserId: string, payload: DetectCoordinatesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detectCoordinates(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.detectCoordinates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dialogs: get, accept, dismiss
         * @param {string} browserId 
         * @param {DialogRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dialog(browserId: string, payload: DialogRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dialog(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.dialog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Emulation: set, clear, list_devices
         * @param {string} browserId 
         * @param {EmulateRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emulate(browserId: string, payload: EmulateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emulate(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.emulate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Execute JavaScript
         * @param {string} browserId 
         * @param {ExecuteScriptRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeScript(browserId: string, payload: ExecuteScriptRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeScript(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.executeScript']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fill multiple form fields
         * @param {string} browserId 
         * @param {FillFormRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fillForm(browserId: string, payload: FillFormRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fillForm(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.fillForm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the WebSocket URL that external tools (Playwright, Puppeteer, etc.) can use to connect directly to Chrome\'s DevTools Protocol for advanced automation like network interception, performance profiling, or custom CDP commands.  The returned URL format: ws://host:port/devtools/browser/{guid}  Note: The URL uses the container\'s internal address. For external access, ensure the CDP port is exposed and use the appropriate host address.
         * @summary Get Chrome DevTools Protocol WebSocket URL for direct CDP access
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCdpEndpoint(browserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCdpEndpoint(browserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.getCdpEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get page HTML
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContent(browserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContent(browserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.getContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get element text, attribute, or property
         * @param {string} browserId 
         * @param {string} selector selector
         * @param {string} dataType data_type
         * @param {string} [name] name
         * @param {string} [by] by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getElementData(browserId: string, selector: string, dataType: string, name?: string, by?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getElementData(browserId, selector, dataType, name, by, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.getElementData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current URL
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUrl(browserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUrl(browserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.getUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary GUI click by selector or coordinates
         * @param {string} browserId 
         * @param {GuiClickRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guiClick(browserId: string, payload: GuiClickRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guiClick(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.guiClick']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary GUI hover at coordinates
         * @param {string} browserId 
         * @param {GuiHoverXyRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guiHoverXy(browserId: string, payload: GuiHoverXyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guiHoverXy(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.guiHoverXy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Press keys at coordinates (click to focus, then send keys)
         * @param {string} browserId 
         * @param {GuiPressKeysXyRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guiPressKeysXy(browserId: string, payload: GuiPressKeysXyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guiPressKeysXy(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.guiPressKeysXy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary GUI type at coordinates - clicks then types text
         * @param {string} browserId 
         * @param {GuiTypeXyRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guiTypeXy(browserId: string, payload: GuiTypeXyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guiTypeXy(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.guiTypeXy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary History: back, forward, or refresh
         * @param {string} browserId 
         * @param {HistoryRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async history(browserId: string, payload: HistoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.history(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.history']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Mouse: hover or drag
         * @param {string} browserId 
         * @param {MouseRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mouse(browserId: string, payload: MouseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mouse(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.mouse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Navigate to URL
         * @param {string} browserId 
         * @param {NavigateBrowserRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async navigateBrowser(browserId: string, payload: NavigateBrowserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.navigateBrowser(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.navigateBrowser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Network logs: get or clear
         * @param {string} browserId 
         * @param {NetworkLogsRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkLogs(browserId: string, payload: NetworkLogsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkLogs(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.networkLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Performance: start_trace, stop_trace, metrics, analyze
         * @param {string} browserId 
         * @param {PerformanceRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async performance(browserId: string, payload: PerformanceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.performance(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.performance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Press keyboard keys
         * @param {string} browserId 
         * @param {PressKeysRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pressKeys(browserId: string, payload: PressKeysRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pressKeys(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.pressKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Resize viewport
         * @param {string} browserId 
         * @param {ResizeRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resize(browserId: string, payload: ResizeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resize(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.resize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Scroll to element/coords or by delta
         * @param {string} browserId 
         * @param {ScrollRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scroll(browserId: string, payload: ScrollRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scroll(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.scroll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Select dropdown: select option or get options
         * @param {string} browserId 
         * @param {SelectRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async select(browserId: string, payload: SelectRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.select(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.select']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary DOM or accessibility snapshot
         * @param {string} browserId 
         * @param {SnapshotRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapshot(browserId: string, payload: SnapshotRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snapshot(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.snapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tabs: list, new, switch, close, current
         * @param {string} browserId 
         * @param {TabsRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tabs(browserId: string, payload: TabsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tabs(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.tabs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Take screenshot
         * @param {string} browserId 
         * @param {TakeScreenshotRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async takeScreenshot(browserId: string, payload: TakeScreenshotRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.takeScreenshot(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.takeScreenshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Type text into element
         * @param {string} browserId 
         * @param {TypeTextRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async typeText(browserId: string, payload: TypeTextRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.typeText(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.typeText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload file to input
         * @param {string} browserId 
         * @param {UploadFileRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(browserId: string, payload: UploadFileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Wait for element to be visible or hidden
         * @param {string} browserId 
         * @param {WaitElementRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitElement(browserId: string, payload: WaitElementRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.waitElement(browserId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.waitElement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary AI page analysis - what\'s visible
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async whatIsVisible(browserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.whatIsVisible(browserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrowserApi.whatIsVisible']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrowserApi - factory interface
 */
export const BrowserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrowserApiFp(configuration)
    return {
        /**
         * 
         * @summary Admin: list all, get info, or close all browsers
         * @param {BrowsersRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        browsers(payload: BrowsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.browsers(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if element exists or is visible
         * @param {string} browserId 
         * @param {string} selector selector
         * @param {string} check check
         * @param {string} [by] by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkElement(browserId: string, selector: string, check: string, by?: string, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.checkElement(browserId, selector, check, by, options).then((request) => request(axios, basePath));
        },
        /**
         * Use if_visible=True to only click if visible.
         * @summary Click element
         * @param {string} browserId 
         * @param {ClickRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        click(browserId: string, payload: ClickRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.click(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Close browser instance
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeBrowser(browserId: string, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.closeBrowser(browserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Console logs: get or clear
         * @param {string} browserId 
         * @param {ConsoleLogsRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consoleLogs(browserId: string, payload: ConsoleLogsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.consoleLogs(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create browser instance with optional persistent profile
         * @param {CreateBrowserRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBrowser(payload: CreateBrowserRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.createBrowser(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Args:     browser_id: Browser instance identifier     prompt: Natural language description of element to find     fx: Fractional x offset for click point (0.0=left, 0.5=center, 1.0=right).         If None, auto-bias is applied for wide elements (0.25 for aspect ratio > 10).     fy: Fractional y offset for click point (0.0=top, 0.5=center, 1.0=bottom).
         * @summary Detect element coordinates using vision
         * @param {string} browserId 
         * @param {DetectCoordinatesRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectCoordinates(browserId: string, payload: DetectCoordinatesRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.detectCoordinates(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Dialogs: get, accept, dismiss
         * @param {string} browserId 
         * @param {DialogRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dialog(browserId: string, payload: DialogRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.dialog(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Emulation: set, clear, list_devices
         * @param {string} browserId 
         * @param {EmulateRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emulate(browserId: string, payload: EmulateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.emulate(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute JavaScript
         * @param {string} browserId 
         * @param {ExecuteScriptRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeScript(browserId: string, payload: ExecuteScriptRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.executeScript(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fill multiple form fields
         * @param {string} browserId 
         * @param {FillFormRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fillForm(browserId: string, payload: FillFormRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.fillForm(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the WebSocket URL that external tools (Playwright, Puppeteer, etc.) can use to connect directly to Chrome\'s DevTools Protocol for advanced automation like network interception, performance profiling, or custom CDP commands.  The returned URL format: ws://host:port/devtools/browser/{guid}  Note: The URL uses the container\'s internal address. For external access, ensure the CDP port is exposed and use the appropriate host address.
         * @summary Get Chrome DevTools Protocol WebSocket URL for direct CDP access
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCdpEndpoint(browserId: string, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.getCdpEndpoint(browserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get page HTML
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContent(browserId: string, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.getContent(browserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get element text, attribute, or property
         * @param {string} browserId 
         * @param {string} selector selector
         * @param {string} dataType data_type
         * @param {string} [name] name
         * @param {string} [by] by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getElementData(browserId: string, selector: string, dataType: string, name?: string, by?: string, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.getElementData(browserId, selector, dataType, name, by, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current URL
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrl(browserId: string, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.getUrl(browserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GUI click by selector or coordinates
         * @param {string} browserId 
         * @param {GuiClickRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guiClick(browserId: string, payload: GuiClickRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.guiClick(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GUI hover at coordinates
         * @param {string} browserId 
         * @param {GuiHoverXyRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guiHoverXy(browserId: string, payload: GuiHoverXyRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.guiHoverXy(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Press keys at coordinates (click to focus, then send keys)
         * @param {string} browserId 
         * @param {GuiPressKeysXyRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guiPressKeysXy(browserId: string, payload: GuiPressKeysXyRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.guiPressKeysXy(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GUI type at coordinates - clicks then types text
         * @param {string} browserId 
         * @param {GuiTypeXyRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guiTypeXy(browserId: string, payload: GuiTypeXyRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.guiTypeXy(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary History: back, forward, or refresh
         * @param {string} browserId 
         * @param {HistoryRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        history(browserId: string, payload: HistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.history(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mouse: hover or drag
         * @param {string} browserId 
         * @param {MouseRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mouse(browserId: string, payload: MouseRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.mouse(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Navigate to URL
         * @param {string} browserId 
         * @param {NavigateBrowserRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        navigateBrowser(browserId: string, payload: NavigateBrowserRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.navigateBrowser(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Network logs: get or clear
         * @param {string} browserId 
         * @param {NetworkLogsRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkLogs(browserId: string, payload: NetworkLogsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.networkLogs(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Performance: start_trace, stop_trace, metrics, analyze
         * @param {string} browserId 
         * @param {PerformanceRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performance(browserId: string, payload: PerformanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.performance(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Press keyboard keys
         * @param {string} browserId 
         * @param {PressKeysRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pressKeys(browserId: string, payload: PressKeysRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.pressKeys(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resize viewport
         * @param {string} browserId 
         * @param {ResizeRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resize(browserId: string, payload: ResizeRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.resize(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Scroll to element/coords or by delta
         * @param {string} browserId 
         * @param {ScrollRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scroll(browserId: string, payload: ScrollRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.scroll(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Select dropdown: select option or get options
         * @param {string} browserId 
         * @param {SelectRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        select(browserId: string, payload: SelectRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.select(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DOM or accessibility snapshot
         * @param {string} browserId 
         * @param {SnapshotRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshot(browserId: string, payload: SnapshotRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.snapshot(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Tabs: list, new, switch, close, current
         * @param {string} browserId 
         * @param {TabsRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tabs(browserId: string, payload: TabsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.tabs(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Take screenshot
         * @param {string} browserId 
         * @param {TakeScreenshotRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        takeScreenshot(browserId: string, payload: TakeScreenshotRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.takeScreenshot(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Type text into element
         * @param {string} browserId 
         * @param {TypeTextRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        typeText(browserId: string, payload: TypeTextRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.typeText(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload file to input
         * @param {string} browserId 
         * @param {UploadFileRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(browserId: string, payload: UploadFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.uploadFile(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Wait for element to be visible or hidden
         * @param {string} browserId 
         * @param {WaitElementRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitElement(browserId: string, payload: WaitElementRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.waitElement(browserId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary AI page analysis - what\'s visible
         * @param {string} browserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whatIsVisible(browserId: string, options?: RawAxiosRequestConfig): AxiosPromise<GenericResponse> {
            return localVarFp.whatIsVisible(browserId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrowserApi - object-oriented interface
 */
export class BrowserApi extends BaseAPI {
    /**
     * 
     * @summary Admin: list all, get info, or close all browsers
     * @param {BrowsersRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public browsers(payload: BrowsersRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).browsers(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if element exists or is visible
     * @param {string} browserId 
     * @param {string} selector selector
     * @param {string} check check
     * @param {string} [by] by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkElement(browserId: string, selector: string, check: string, by?: string, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).checkElement(browserId, selector, check, by, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use if_visible=True to only click if visible.
     * @summary Click element
     * @param {string} browserId 
     * @param {ClickRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public click(browserId: string, payload: ClickRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).click(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Close browser instance
     * @param {string} browserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public closeBrowser(browserId: string, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).closeBrowser(browserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Console logs: get or clear
     * @param {string} browserId 
     * @param {ConsoleLogsRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public consoleLogs(browserId: string, payload: ConsoleLogsRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).consoleLogs(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create browser instance with optional persistent profile
     * @param {CreateBrowserRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createBrowser(payload: CreateBrowserRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).createBrowser(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Args:     browser_id: Browser instance identifier     prompt: Natural language description of element to find     fx: Fractional x offset for click point (0.0=left, 0.5=center, 1.0=right).         If None, auto-bias is applied for wide elements (0.25 for aspect ratio > 10).     fy: Fractional y offset for click point (0.0=top, 0.5=center, 1.0=bottom).
     * @summary Detect element coordinates using vision
     * @param {string} browserId 
     * @param {DetectCoordinatesRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public detectCoordinates(browserId: string, payload: DetectCoordinatesRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).detectCoordinates(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Dialogs: get, accept, dismiss
     * @param {string} browserId 
     * @param {DialogRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public dialog(browserId: string, payload: DialogRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).dialog(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Emulation: set, clear, list_devices
     * @param {string} browserId 
     * @param {EmulateRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public emulate(browserId: string, payload: EmulateRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).emulate(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute JavaScript
     * @param {string} browserId 
     * @param {ExecuteScriptRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public executeScript(browserId: string, payload: ExecuteScriptRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).executeScript(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fill multiple form fields
     * @param {string} browserId 
     * @param {FillFormRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public fillForm(browserId: string, payload: FillFormRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).fillForm(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the WebSocket URL that external tools (Playwright, Puppeteer, etc.) can use to connect directly to Chrome\'s DevTools Protocol for advanced automation like network interception, performance profiling, or custom CDP commands.  The returned URL format: ws://host:port/devtools/browser/{guid}  Note: The URL uses the container\'s internal address. For external access, ensure the CDP port is exposed and use the appropriate host address.
     * @summary Get Chrome DevTools Protocol WebSocket URL for direct CDP access
     * @param {string} browserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCdpEndpoint(browserId: string, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).getCdpEndpoint(browserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get page HTML
     * @param {string} browserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getContent(browserId: string, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).getContent(browserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get element text, attribute, or property
     * @param {string} browserId 
     * @param {string} selector selector
     * @param {string} dataType data_type
     * @param {string} [name] name
     * @param {string} [by] by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getElementData(browserId: string, selector: string, dataType: string, name?: string, by?: string, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).getElementData(browserId, selector, dataType, name, by, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current URL
     * @param {string} browserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUrl(browserId: string, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).getUrl(browserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GUI click by selector or coordinates
     * @param {string} browserId 
     * @param {GuiClickRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public guiClick(browserId: string, payload: GuiClickRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).guiClick(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GUI hover at coordinates
     * @param {string} browserId 
     * @param {GuiHoverXyRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public guiHoverXy(browserId: string, payload: GuiHoverXyRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).guiHoverXy(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Press keys at coordinates (click to focus, then send keys)
     * @param {string} browserId 
     * @param {GuiPressKeysXyRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public guiPressKeysXy(browserId: string, payload: GuiPressKeysXyRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).guiPressKeysXy(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GUI type at coordinates - clicks then types text
     * @param {string} browserId 
     * @param {GuiTypeXyRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public guiTypeXy(browserId: string, payload: GuiTypeXyRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).guiTypeXy(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary History: back, forward, or refresh
     * @param {string} browserId 
     * @param {HistoryRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public history(browserId: string, payload: HistoryRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).history(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mouse: hover or drag
     * @param {string} browserId 
     * @param {MouseRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mouse(browserId: string, payload: MouseRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).mouse(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Navigate to URL
     * @param {string} browserId 
     * @param {NavigateBrowserRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public navigateBrowser(browserId: string, payload: NavigateBrowserRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).navigateBrowser(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Network logs: get or clear
     * @param {string} browserId 
     * @param {NetworkLogsRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public networkLogs(browserId: string, payload: NetworkLogsRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).networkLogs(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Performance: start_trace, stop_trace, metrics, analyze
     * @param {string} browserId 
     * @param {PerformanceRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public performance(browserId: string, payload: PerformanceRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).performance(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Press keyboard keys
     * @param {string} browserId 
     * @param {PressKeysRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pressKeys(browserId: string, payload: PressKeysRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).pressKeys(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resize viewport
     * @param {string} browserId 
     * @param {ResizeRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resize(browserId: string, payload: ResizeRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).resize(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Scroll to element/coords or by delta
     * @param {string} browserId 
     * @param {ScrollRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public scroll(browserId: string, payload: ScrollRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).scroll(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Select dropdown: select option or get options
     * @param {string} browserId 
     * @param {SelectRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public select(browserId: string, payload: SelectRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).select(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DOM or accessibility snapshot
     * @param {string} browserId 
     * @param {SnapshotRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public snapshot(browserId: string, payload: SnapshotRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).snapshot(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Tabs: list, new, switch, close, current
     * @param {string} browserId 
     * @param {TabsRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tabs(browserId: string, payload: TabsRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).tabs(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Take screenshot
     * @param {string} browserId 
     * @param {TakeScreenshotRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public takeScreenshot(browserId: string, payload: TakeScreenshotRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).takeScreenshot(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Type text into element
     * @param {string} browserId 
     * @param {TypeTextRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public typeText(browserId: string, payload: TypeTextRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).typeText(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload file to input
     * @param {string} browserId 
     * @param {UploadFileRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadFile(browserId: string, payload: UploadFileRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).uploadFile(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Wait for element to be visible or hidden
     * @param {string} browserId 
     * @param {WaitElementRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public waitElement(browserId: string, payload: WaitElementRequest, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).waitElement(browserId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary AI page analysis - what\'s visible
     * @param {string} browserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public whatIsVisible(browserId: string, options?: RawAxiosRequestConfig) {
        return BrowserApiFp(this.configuration).whatIsVisible(browserId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check the health status of the browser pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Prometheus-style metrics for monitoring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prometheusMetrics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Check the health status of the browser pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Prometheus-style metrics for monitoring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prometheusMetrics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prometheusMetrics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.prometheusMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary Check the health status of the browser pool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: RawAxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.healthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Prometheus-style metrics for monitoring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prometheusMetrics(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.prometheusMetrics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @summary Check the health status of the browser pool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthCheck(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Prometheus-style metrics for monitoring
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public prometheusMetrics(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).prometheusMetrics(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PoolApi - axios parameter creator
 */
export const PoolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Scale the browser pool to a new maximum size
         * @param {ScalePool} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scalePool: async (payload: ScalePool, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('scalePool', 'payload', payload)
            const localVarPath = `/pool/scale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gracefully shutdown the browser pool server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownServer: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pool/shutdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoolApi - functional programming interface
 */
export const PoolApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoolApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Scale the browser pool to a new maximum size
         * @param {ScalePool} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scalePool(payload: ScalePool, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoolScaled>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scalePool(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolApi.scalePool']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gracefully shutdown the browser pool server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shutdownServer(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shutdownServer(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoolApi.shutdownServer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PoolApi - factory interface
 */
export const PoolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoolApiFp(configuration)
    return {
        /**
         * 
         * @summary Scale the browser pool to a new maximum size
         * @param {ScalePool} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scalePool(payload: ScalePool, options?: RawAxiosRequestConfig): AxiosPromise<PoolScaled> {
            return localVarFp.scalePool(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gracefully shutdown the browser pool server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownServer(options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
            return localVarFp.shutdownServer(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoolApi - object-oriented interface
 */
export class PoolApi extends BaseAPI {
    /**
     * 
     * @summary Scale the browser pool to a new maximum size
     * @param {ScalePool} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public scalePool(payload: ScalePool, options?: RawAxiosRequestConfig) {
        return PoolApiFp(this.configuration).scalePool(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gracefully shutdown the browser pool server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public shutdownServer(options?: RawAxiosRequestConfig) {
        return PoolApiFp(this.configuration).shutdownServer(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfilesApi - axios parameter creator
 */
export const ProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new browser profile
         * @param {CreateProfileRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile: async (payload: CreateProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createProfile', 'payload', payload)
            const localVarPath = `/profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a browser profile
         * @param {string} profileName Profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile: async (profileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileName' is not null or undefined
            assertParamExists('deleteProfile', 'profileName', profileName)
            const localVarPath = `/profiles/{profile_name}`
                .replace(`{${"profile_name"}}`, encodeURIComponent(String(profileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get profile information
         * @param {string} profileName Profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (profileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileName' is not null or undefined
            assertParamExists('getProfile', 'profileName', profileName)
            const localVarPath = `/profiles/{profile_name}`
                .replace(`{${"profile_name"}}`, encodeURIComponent(String(profileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all browser profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilesApi - functional programming interface
 */
export const ProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new browser profile
         * @param {CreateProfileRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfile(payload: CreateProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfile(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.createProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a browser profile
         * @param {string} profileName Profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfile(profileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfile(profileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.deleteProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get profile information
         * @param {string} profileName Profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(profileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(profileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.getProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all browser profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProfiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProfiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.listProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfilesApi - factory interface
 */
export const ProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new browser profile
         * @param {CreateProfileRequest} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(payload: CreateProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse> {
            return localVarFp.createProfile(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a browser profile
         * @param {string} profileName Profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(profileName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteProfile(profileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get profile information
         * @param {string} profileName Profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(profileName: string, options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse> {
            return localVarFp.getProfile(profileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all browser profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfiles(options?: RawAxiosRequestConfig): AxiosPromise<ProfileListResponse> {
            return localVarFp.listProfiles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilesApi - object-oriented interface
 */
export class ProfilesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new browser profile
     * @param {CreateProfileRequest} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProfile(payload: CreateProfileRequest, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).createProfile(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a browser profile
     * @param {string} profileName Profile name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteProfile(profileName: string, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).deleteProfile(profileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get profile information
     * @param {string} profileName Profile name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProfile(profileName: string, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).getProfile(profileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all browser profiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProfiles(options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).listProfiles(options).then((request) => request(this.axios, this.basePath));
    }
}



